<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MyBatisæºç æ·±åº¦è§£æ - å±å±çš„åšå®¢</title>
  <meta name="description" content="{{post.excerpt}}">
  <link rel="stylesheet" href="/assets/style.css">
</head>
<body>
  <div class="background-animation"></div>
  <div class="background-animation background-animation-2"></div>
  
  <header class="header">
    <div class="container">
      <nav class="nav">
        <a href="/" class="logo">å±å±çš„åšå®¢</a>
        <div class="nav-links">
          <a href="/" class="nav-link">é¦–é¡µ</a>
          <a href="/archives/" class="nav-link">å½’æ¡£</a>
        </div>
        <button class="theme-toggle" aria-label="åˆ‡æ¢ä¸»é¢˜">
          <span class="theme-icon">ğŸŒ™</span>
        </button>
      </nav>
    </div>
  </header>

  <main class="main">
    <div class="container">
      <article class="post">
        <div class="post-header">
          <a href="/" class="back-link">â† è¿”å›é¦–é¡µ</a>
          <h1 class="post-title">MyBatisæºç æ·±åº¦è§£æ</h1>
          <div class="post-meta">
            <span class="post-date">2026å¹´2æœˆ11æ—¥</span>
            
          </div>
        </div>
        
        <div class="post-content">
          <h1>MyBatis æºç æ·±åº¦è§£æ</h1><h2>ä¸€ã€MyBatis ç®€ä»‹</h2><p>MyBatis æ˜¯ä¸€æ¬¾ä¼˜ç§€çš„æŒä¹…å±‚æ¡†æ¶ï¼Œå®ƒæ”¯æŒå®šåˆ¶åŒ– SQLã€å­˜å‚¨è¿‡ç¨‹ä»¥åŠé«˜çº§æ˜ å°„ã€‚MyBatis é¿å…äº†å‡ ä¹æ‰€æœ‰çš„ JDBC ä»£ç å’Œæ‰‹åŠ¨è®¾ç½®å‚æ•°ä»¥åŠè·å–ç»“æœé›†çš„å·¥ä½œã€‚MyBatis å¯ä»¥ä½¿ç”¨ç®€å•çš„ XML æˆ–æ³¨è§£æ¥é…ç½®å’Œæ˜ å°„åŸç”Ÿä¿¡æ¯ï¼Œå°†æ¥å£å’Œ Java çš„ POJOsï¼ˆPlain Old Java Objectsï¼Œæ™®é€šçš„ Javaå¯¹è±¡ï¼‰æ˜ å°„æˆæ•°æ®åº“ä¸­çš„è®°å½•ã€‚</p><h3>æ ¸å¿ƒç‰¹ç‚¹</h3><ul><ol><li>åŸºäº SQL æ˜ å°„çš„æŒä¹…å±‚æ¡†æ¶</li>
<li>æ”¯æŒåŠ¨æ€ SQL è¯­å¥</li>
<li>æ”¯æŒç¼“å­˜æœºåˆ¶</li>
<li>æä¾›äº†ä¸ Spring çš„æ— ç¼é›†æˆ</li>
<li>çµæ´»çš„æ˜ å°„é…ç½®ï¼ˆXML æˆ–æ³¨è§£ï¼‰</li>
</ol></ul>
<h2>äºŒã€MyBatis æ ¸å¿ƒæ¶æ„</h2><p>MyBatis çš„æ ¸å¿ƒæ¶æ„ç”±ä»¥ä¸‹å‡ ä¸ªå±‚æ¬¡ç»„æˆï¼š</p><p><pre class="language-text" data-lang="text"><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         API Interface Layer             â”‚
â”‚  (SqlSession, Mapper Interface)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Data Processing Layer              â”‚
â”‚  (ParameterHandler, ResultSetHandler)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Statement Handling Layer          â”‚
â”‚      (StatementHandler, Executor)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Core Supporting Layer             â”‚
â”‚  (Configuration, XMLConfigBuilder)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></p><h3>2.1 æ ¸å¿ƒç»„ä»¶</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public class Configuration {
    protected Environment environment;
    protected boolean safeRowBoundsEnabled;
    protected boolean safeResultHandlerEnabled;
    protected boolean mapUnderscoreToCamelCase;
    protected boolean aggressiveLazyLoading;
    protected boolean multipleResultSetsEnabled;
    protected boolean useGeneratedKeys;
    protected boolean useColumnLabel;
    protected boolean cacheEnabled;
    protected boolean callSettersOnNulls;
    
    protected Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;("Mapped Statements collection");
    protected Map&lt;String, Cache&gt; caches = new StrictMap&lt;Cache&gt;("Caches collection");
    protected Map&lt;String, ResultMap&gt; resultMaps = new StrictMap&lt;ResultMap&gt;("Result Maps collection");
    protected Map&lt;String, ParameterMap&gt; parameterMaps = new StrictMap&lt;ParameterMap&gt;("Parameter Maps collection");
    protected Map&lt;String, KeyGenerator&gt; keyGenerators = new StrictMap&lt;KeyGenerator&gt;("Key Generators collection");
    
    protected TypeHandlerRegistry typeHandlerRegistry = new TypeHandlerRegistry();
    protected TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();
    protected ObjectFactory objectFactory = new DefaultObjectFactory();
    protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();
    protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory();
}
</code></pre></p><h2>ä¸‰ã€MyBatis åˆå§‹åŒ–æµç¨‹</h2><h3>3.1 æ•´ä½“åˆå§‹åŒ–æµç¨‹å›¾</h3><p><pre class="language-text" data-lang="text"><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åŠ è½½é…ç½®æ–‡ä»¶  â”‚
â”‚ mybatis.xml â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SqlSessionFactory  â”‚
â”‚    .Builder.build()  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ XMLConfigBuilder    â”‚
â”‚   è§£æé…ç½®æ–‡ä»¶       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ XMLMapperBuilder    â”‚
â”‚   è§£ææ˜ å°„æ–‡ä»¶       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Configuration     â”‚
â”‚   (æ ¸å¿ƒé…ç½®å¯¹è±¡)     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DefaultSqlSession  â”‚
â”‚   Factory          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></p><h3>3.2 åˆå§‹åŒ–æºç åˆ†æ</h3><h4>3.2.1 SqlSessionFactory æ„å»º</h4><p><pre class="language-java" data-lang="java"><code class="language-java">public class SqlSessionFactoryBuilder {
    
    public SqlSessionFactory build(InputStream inputStream) {
        return build(inputStream, null, null);
    }
    
    public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
        try {
            XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
            return build(parser.parse());
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error building SqlSession.", e);
        } finally {
            ErrorContext.instance().reset();
            try {
                inputStream.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
    
    public SqlSessionFactory build(Configuration config) {
        return new DefaultSqlSessionFactory(config);
    }
}
</code></pre></p><h4>3.2.2 XMLConfigBuilder è§£æé…ç½®</h4><p><pre class="language-java" data-lang="java"><code class="language-java">public class XMLConfigBuilder extends BaseBuilder {
    
    private boolean parsed;
    private final XPathParser parser;
    private String environment;
    
    public Configuration parse() {
        if (parsed) {
            throw new BuilderException("Each XMLConfigBuilder can only be used once.");
        }
        parsed = true;
        parseConfiguration(parser.evalNode("/configuration"));
        return configuration;
    }
    
    private void parseConfiguration(XNode root) {
        try {
            propertiesElement(root.evalNode("properties"));
            settingsAsProperties(root.evalNode("settings"));
            typeAliasesElement(root.evalNode("typeAliases"));
            pluginElement(root.evalNode("plugins"));
            objectFactoryElement(root.evalNode("objectFactory"));
            objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
            reflectorFactoryElement(root.evalNode("reflectorFactory"));
            settingsElement(settings);
            environmentsElement(root.evalNode("environments"));
            databaseIdProviderElement(root.evalNode("databaseIdProvider"));
            typeHandlerElement(root.evalNode("typeHandlers"));
            mapperElement(root.evalNode("mappers"));
        } catch (Exception e) {
            throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
        }
    }
}
</code></pre></p><h4>3.2.3 Mapper è§£æ</h4><p><pre class="language-java" data-lang="java"><code class="language-java">public class XMLMapperBuilder extends BaseBuilder {
    
    public void parse() {
        if (!configuration.isResourceLoaded(resource)) {
            configurationElement(parser.evalNode("/mapper"));
            configuration.addLoadedResource(resource);
            bindMapperForNamespace();
        }
        parsePendingResultMaps();
        parsePendingCacheRefs();
        parsePendingStatements();
    }
    
    private void configurationElement(XNode context) {
        try {
            String namespace = context.getStringAttribute("namespace");
            if (namespace == null || namespace.isEmpty()) {
                throw new BuilderException("Mapper's namespace cannot be empty");
            }
            builderAssistant.setCurrentNamespace(namespace);
            cacheRefElement(context.evalNode("cache-ref"));
            cacheElement(context.evalNode("cache"));
            parameterMapElement(context.evalNodes("/mapper/parameterMap"));
            resultMapElements(context.evalNodes("/mapper/resultMap"));
            sqlElement(context.evalNodes("/mapper/sql"));
            buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
        } catch (Exception e) {
            throw new BuilderException("Error parsing Mapper XML. Cause: " + e, e);
        }
    }
}
</code></pre></p><h2>å››ã€SQL æ‰§è¡Œæ ¸å¿ƒæµç¨‹</h2><h3>4.1 SQL æ‰§è¡Œå®Œæ•´æµç¨‹å›¾</h3><p><pre class="language-text" data-lang="text"><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è·å– Mapper  â”‚
â”‚   æ¥å£å®ä¾‹    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MapperProxy      â”‚
â”‚  (åŠ¨æ€ä»£ç†)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MapperMethod    â”‚
â”‚  (æ–¹æ³•å°è£…)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SqlSession      â”‚
â”‚  (ä¼šè¯ç®¡ç†)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Executor        â”‚
â”‚  (æ‰§è¡Œå™¨)         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ StatementHandler â”‚
â”‚  (è¯­å¥å¤„ç†)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ParameterHandlerâ”‚
â”‚  (å‚æ•°è®¾ç½®)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ResultSet       â”‚
â”‚  Handler         â”‚
â”‚  (ç»“æœé›†å¤„ç†)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></p><h3>4.2 Mapper åŠ¨æ€ä»£ç†æœºåˆ¶</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public class MapperProxy&lt;T&gt; implements InvocationHandler {
    
    private final SqlSession sqlSession;
    private final Class&lt;T&gt; mapperInterface;
    private final Map&lt;Method, MapperMethod&gt; methodCache;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if (Object.class.equals(method.getDeclaringClass())) {
                return method.invoke(this, args);
            } else if (isDefaultMethod(method)) {
                return invokeDefaultMethod(proxy, method, args);
            }
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
        final MapperMethod mapperMethod = cachedMapperMethod(method);
        return mapperMethod.execute(sqlSession, args);
    }
    
    private MapperMethod cachedMapperMethod(Method method) {
        MapperMethod mapperMethod = methodCache.get(method);
        if (mapperMethod == null) {
            mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
            methodCache.put(method, mapperMethod);
        }
        return mapperMethod;
    }
}
</code></pre></p><h3>4.3 MapperMethod æ‰§è¡Œé€»è¾‘</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public class MapperMethod {
    
    private final SqlCommand command;
    private final MethodSignature method;
    
    public Object execute(SqlSession sqlSession, Object[] args) {
        Object result;
        switch (command.getType()) {
            case INSERT: {
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.insert(command.getName(), param));
                break;
            }
            case UPDATE: {
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.update(command.getName(), param));
                break;
            }
            case DELETE: {
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.delete(command.getName(), param));
                break;
            }
            case SELECT:
                if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
                    executeWithResultHandler(sqlSession, args);
                    result = null;
                } else if (method.returnsMany()) {
                    result = executeForMany(sqlSession, args);
                } else if (method.returnsMap()) {
                    result = executeForMap(sqlSession, args);
                } else if (method.returnsCursor()) {
                    result = executeForCursor(sqlSession, args);
                } else {
                    Object param = method.convertArgsToSqlCommandParam(args);
                    result = sqlSession.selectOne(command.getName(), param);
                }
                break;
            case FLUSH:
                result = sqlSession.flushStatements();
                break;
            default:
                throw new BindingException("Unknown execution method for: " + command.getName());
        }
        if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
            throw new BindingException("Mapper method '" + command.getName() 
                + " attempted to return null from a method with a primitive return type (" + method.getReturnType() + ").");
        }
        return result;
    }
}
</code></pre></p><h3>4.4 SqlSession æ‰§è¡Œæµç¨‹</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public class DefaultSqlSession implements SqlSession {
    
    private final Configuration configuration;
    private final Executor executor;
    
    @Override
    public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
        try {
            MappedStatement ms = configuration.getMappedStatement(statement);
            return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error querying database. Cause: " + e, e);
        } finally {
            ErrorContext.instance().reset();
        }
    }
    
    @Override
    public &lt;T&gt; T selectOne(String statement, Object parameter) {
        List&lt;T&gt; list = this.&lt;T&gt;selectList(statement, parameter);
        if (list.size() == 1) {
            return list.get(0);
        } else if (list.size() &gt; 1) {
            throw new TooManyResultsException("Expected one result (or null) to be returned by selectOne(), but found: " + list.size());
        } else {
            return null;
        }
    }
}
</code></pre></p><h2>äº”ã€Executor æ‰§è¡Œå™¨</h2><h3>5.1 Executor ç»§æ‰¿ä½“ç³»</h3><p><pre class="language-text" data-lang="text"><code class="language-text">        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Executor   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BaseExecutorâ”‚  â”‚ CachingExecutorâ”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
  â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚    â”‚        â”‚        â”‚
â”Œâ”€â–¼â”€â”â”Œâ”€â–¼â”€â”€â”€â”â”Œâ”€â”€â–¼â”€â”€â”â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚Simpleâ”‚Reuseâ”‚Batchâ”‚Closedâ”‚
â”‚Executorâ”‚Executorâ”‚Executorâ”‚Executorâ”‚
â””â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></p><h3>5.2 BaseExecutor æ ¸å¿ƒå®ç°</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public abstract class BaseExecutor implements Executor {
    
    protected Transaction transaction;
    protected Wrapper wrapper;
    protected ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;
    protected PerpetualCache localCache;
    protected PerpetualCache localOutputParameterCache;
    protected Configuration configuration;
    
    protected List&lt;BatchResult&gt; batchResults = new ArrayList&lt;&gt;();
    protected int queryStack = 0;
    
    @Override
    public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
        BoundSql boundSql = ms.getBoundSql(parameter);
        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
        return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
    }
    
    @SuppressWarnings("unchecked")
    @Override
    public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
        if (closed) {
            throw new ExecutorException("Executor was closed.");
        }
        if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
            clearLocalCache();
        }
        List&lt;E&gt; list;
        try {
            queryStack++;
            list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
            if (list != null) {
                handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
            } else {
                list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
            }
        } finally {
            queryStack--;
        }
        if (queryStack == 0) {
            for (DeferredLoad deferredLoad : deferredLoads) {
                deferredLoad.load();
            }
            deferredLoads.clear();
            if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
                clearLocalCache();
            }
        }
        return list;
    }
    
    private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        List&lt;E&gt; list;
        localCache.putObject(key, EXECUTION_PLACEHOLDER);
        try {
            list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
        } finally {
            localCache.removeObject(key);
        }
        localCache.putObject(key, list);
        if (ms.getStatementType() == StatementType.CALLABLE) {
            localOutputParameterCache.putObject(key, parameter);
        }
        return list;
    }
    
    protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;
}
</code></pre></p><h3>5.3 SimpleExecutor å®ç°</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public class SimpleExecutor extends BaseExecutor {
    
    @Override
    public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
        Statement stmt = null;
        try {
            Configuration configuration = ms.getConfiguration();
            StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
            stmt = prepareStatement(handler, ms.getStatementLog());
            return handler.&lt;E&gt;query(stmt, resultHandler);
        } finally {
            closeStatement(stmt);
        }
    }
    
    private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
        Statement stmt;
        Connection connection = getConnection(statementLog);
        stmt = handler.prepare(connection, transaction.getTimeout());
        handler.parameterize(stmt);
        return stmt;
    }
}
</code></pre></p><h2>å…­ã€StatementHandler è¯­å¥å¤„ç†å™¨</h2><h3>6.1 StatementHandler ç»§æ‰¿ä½“ç³»</h3><p><pre class="language-text" data-lang="text"><code class="language-text">         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ StatementHandlerâ”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚Base   â”‚   â”‚Callableâ”‚   â”‚Routing â”‚
â”‚Statementâ”‚ â”‚Handler â”‚ â”‚Handler â”‚
â”‚Handlerâ”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”¬â”€â”€â”€â”˜
    â”‚
â”Œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚            â”‚          â”‚
â”Œâ–¼â”€â”â”Œâ–¼â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚Simpleâ”‚Prepareâ”‚Callableâ”‚Callableâ”‚
â”‚Statementâ”‚dStatementâ”‚Handler â”‚Handler â”‚
â”‚Handlerâ”‚Handlerâ”‚Handler â”‚Handler â”‚
â””â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></p><h3>6.2 PreparedStatementHandler å®ç°</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public class PreparedStatementHandler extends BaseStatementHandler {
    
    @Override
    public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
        PreparedStatement ps = (PreparedStatement) statement;
        ps.execute();
        return resultSetHandler.&lt;E&gt;handleResultSets(ps);
    }
    
    @Override
    protected Statement instantiateStatement(Connection connection) throws SQLException {
        String sql = boundSql.getSql();
        if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) {
            String[] keyColumnNames = mappedStatement.getKeyColumns();
            if (keyColumnNames == null) {
                return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
            } else {
                return connection.prepareStatement(sql, keyColumnNames);
            }
        } else if (mappedStatement.getResultSetType() != null) {
            return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);
        } else {
            return connection.prepareStatement(sql);
        }
    }
    
    @Override
    public void parameterize(Statement statement) throws SQLException {
        parameterHandler.setParameters((PreparedStatement) statement);
    }
}
</code></pre></p><h3>6.3 ParameterHandler å‚æ•°å¤„ç†å™¨</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public interface ParameterHandler {
    Object getParameterObject();
    void setParameters(PreparedStatement ps) throws SQLException;
}

public class DefaultParameterHandler implements ParameterHandler {
    
    private final TypeHandlerRegistry typeHandlerRegistry;
    private final MappedStatement mappedStatement;
    private final Object parameterObject;
    private final BoundSql boundSql;
    private final Configuration configuration;
    
    @Override
    public void setParameters(PreparedStatement ps) {
        ErrorContext.instance().activity("setting parameters").object(mappedStatement.getParameterMap().getId());
        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
        if (parameterMappings != null) {
            for (int i = 0; i &lt; parameterMappings.size(); i++) {
                ParameterMapping parameterMapping = parameterMappings.get(i);
                if (parameterMapping.getMode() != ParameterMode.OUT) {
                    Object value;
                    String propertyName = parameterMapping.getProperty();
                    if (boundSql.hasAdditionalParameter(propertyName)) {
                        value = boundSql.getAdditionalParameter(propertyName);
                    } else if (parameterObject == null) {
                        value = null;
                    } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
                        value = parameterObject;
                    } else {
                        MetaObject metaObject = configuration.newMetaObject(parameterObject);
                        value = metaObject.getValue(propertyName);
                    }
                    TypeHandler typeHandler = parameterMapping.getTypeHandler();
                    JdbcType jdbcType = parameterMapping.getJdbcType();
                    if (value == null &amp;&amp; jdbcType == null) {
                        jdbcType = configuration.getJdbcTypeForNull();
                    }
                    try {
                        typeHandler.setParameter(ps, i + 1, value, jdbcType);
                    } catch (TypeException e) {
                        throw new TypeException("Could not set parameters for mapping: " + parameterMapping + ". Cause: " + e, e);
                    } catch (SQLException e) {
                        throw new TypeException("Could not set parameters for mapping: " + parameterMapping + ". Cause: " + e, e);
                    }
                }
            }
        }
    }
}
</code></pre></p><h3>6.4 ResultSetHandler ç»“æœé›†å¤„ç†å™¨</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public interface ResultSetHandler {
    &lt;E&gt; List&lt;E&gt; handleResultSets(Statement stmt) throws SQLException;
    &lt;E&gt; Cursor&lt;E&gt; handleCursorResultSets(Statement stmt) throws SQLException;
    void handleOutputParameters(CallableStatement cs) throws SQLException;
}

public class DefaultResultSetHandler implements ResultSetHandler {
    
    @Override
    public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
        ErrorContext.instance().activity("handling results").object(mappedStatement.getId());
        
        final List&lt;Object&gt; multipleResults = new ArrayList&lt;&gt;();
        int resultSetCount = 0;
        ResultSetWrapper rsw = getFirstResultSet(stmt);
        
        List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
        int resultMapCount = resultMaps.size();
        validateResultMapsCount(rsw, resultMapCount);
        
        while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
            ResultMap resultMap = resultMaps.get(resultSetCount);
            handleResultSet(rsw, resultMap, multipleResults, null);
            rsw = getNextResultSet(stmt);
            cleanUpAfterHandlingResultSet();
            resultSetCount++;
        }
        
        String[] resultSets = mappedStatement.getResultSets();
        if (resultSets != null) {
            while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
                ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
                if (parentMapping != null) {
                    String nestedResultMapId = parentMapping.getNestedResultMapId();
                    ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
                    handleResultSet(rsw, resultMap, null, parentMapping);
                }
                rsw = getNextResultSet(stmt);
                cleanUpAfterHandlingResultSet();
                resultSetCount++;
            }
        }
        
        return collapseSingleResultList(multipleResults);
    }
    
    private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException {
        try {
            if (parentMapping != null) {
                handleRowValuesForNestedResultMap(rsw, resultMap, null, parentMapping);
            } else {
                if (resultHandler == null) {
                    handleRowValuesForDefaultResultMap(rsw, resultMap, multipleResults, null);
                } else {
                    handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, null, null);
                }
            }
        } finally {
            closeResultSet(rsw.getResultSet());
        }
    }
}
</code></pre></p><h2>ä¸ƒã€ç¼“å­˜æœºåˆ¶</h2><h3>7.1 MyBatis ç¼“å­˜ç»“æ„</h3><p><pre class="language-text" data-lang="text"><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Cache æ¥å£                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                 â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚Perpetualâ”‚    â”‚  Blocking â”‚
â”‚Cache    â”‚    â”‚Cache      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    è£…é¥°å™¨æ¨¡å¼                â”‚
â”‚  LruCache / FifoCache     â”‚
â”‚  SoftCache / WeakCache     â”‚
â”‚  LoggingCache / SyncCache  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></p><h3>7.2 ç¼“å­˜å®ç°</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public class PerpetualCache implements Cache {
    
    private final String id;
    private Map&lt;Object, Object&gt; cache = new HashMap&lt;&gt;();
    
    public PerpetualCache(String id) {
        this.id = id;
    }
    
    @Override
    public String getId() {
        return id;
    }
    
    @Override
    public int getSize() {
        return cache.size();
    }
    
    @Override
    public void putObject(Object key, Object value) {
        cache.put(key, value);
    }
    
    @Override
    public Object getObject(Object key) {
        return cache.get(key);
    }
    
    @Override
    public Object removeObject(Object key) {
        return cache.remove(key);
    }
    
    @Override
    public void clear() {
        cache.clear();
    }
}
</code></pre></p><h2>å…«ã€åŠ¨æ€ SQL æœºåˆ¶</h2><h3>8.1 åŠ¨æ€ SQL æ‰§è¡Œæµç¨‹</h3><p><pre class="language-text" data-lang="text"><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è§£æ XML        â”‚
â”‚  åŠ¨æ€ SQL æ ‡ç­¾   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SqlSource       â”‚
â”‚  (SQL æº)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DynamicContext  â”‚
â”‚  (åŠ¨æ€ä¸Šä¸‹æ–‡)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SqlNode         â”‚
â”‚  (SQL èŠ‚ç‚¹)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BoundSql        â”‚
â”‚  (ç»‘å®š SQL)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></p><h3>8.2 SqlNode å®ç°</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public interface SqlNode {
    boolean apply(DynamicContext context);
}

public class IfSqlNode implements SqlNode {
    
    private final ExpressionEvaluator evaluator;
    private final String test;
    private final SqlNode contents;
    
    public IfSqlNode(SqlNode contents, String test) {
        this.test = test;
        this.contents = contents;
        this.evaluator = new ExpressionEvaluator();
    }
    
    @Override
    public boolean apply(DynamicContext context) {
        if (evaluator.evaluateBoolean(test, context.getBindings())) {
            contents.apply(context);
            return true;
        }
        return false;
    }
}

public class ForEachSqlNode implements SqlNode {
    
    public static final String ITEM_PREFIX = "__frch_";
    
    private final ExpressionEvaluator evaluator;
    private final String collectionExpression;
    private final SqlNode contents;
    private final String open;
    private final String close;
    private final String separator;
    private final String item;
    private final String index;
    private final String itemName;
    private final String indexName;
    
    @Override
    public boolean apply(DynamicContext context) {
        Map&lt;String, Object&gt; bindings = context.getBindings();
        final Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings);
        if (!iterable.iterator().hasNext()) {
            return true;
        }
        boolean first = true;
        applyOpen(context);
        int i = 0;
        for (Object o : iterable) {
            DynamicContext oldContext = context;
            if (first) {
                first = false;
            } else {
                applySeparator(context);
            }
            applyItem(context, o, i);
            contents.apply(new FilteredDynamicContext(oldContext, index, item, i));
            i++;
        }
        applyClose(context);
        return true;
    }
}
</code></pre></p><h2>ä¹ã€æ’ä»¶æœºåˆ¶</h2><h3>9.1 æ‹¦æˆªå™¨é“¾</h3><p><pre class="language-java" data-lang="java"><code class="language-java">public interface Interceptor {
    Object intercept(Invocation invocation) throws Throwable;
    Object plugin(Object target);
    void setProperties(Properties properties);
}

public class InterceptorChain {
    
    private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();
    
    public Object pluginAll(Object target) {
        for (Interceptor interceptor : interceptors) {
            target = interceptor.plugin(target);
        }
        return target;
    }
    
    public void addInterceptor(Interceptor interceptor) {
        interceptors.add(interceptor);
    }
    
    public List&lt;Interceptor&gt; getInterceptors() {
        return Collections.unmodifiableList(interceptors);
    }
}

public class Plugin implements InvocationHandler {
    
    private final Object target;
    private final Interceptor interceptor;
    private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;
    
    private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) {
        this.target = target;
        this.interceptor = interceptor;
        this.signatureMap = signatureMap;
    }
    
    public static Object wrap(Object target, Interceptor interceptor) {
        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);
        Class&lt;?&gt; type = target.getClass();
        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);
        if (interfaces.length &gt; 0) {
            return Proxy.newProxyInstance(
                type.getClassLoader(),
                interfaces,
                new Plugin(target, interceptor, signatureMap));
        }
        return target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());
            if (methods != null &amp;&amp; methods.contains(method)) {
                return interceptor.intercept(new Invocation(target, method, args));
            }
            return method.invoke(target, args);
        } catch (Exception e) {
            throw ExceptionUtil.unwrapThrowable(e);
        }
    }
}
</code></pre></p><h2>åã€æ€»ç»“</h2><h3>10.1 MyBatis æ ¸å¿ƒæµç¨‹æ€»ç»“</h3><ol><li><strong>åˆå§‹åŒ–é˜¶æ®µ</strong>ï¼š</li>
</ol>   - è§£æé…ç½®æ–‡ä»¶ï¼ˆXMLConfigBuilderï¼‰
   - è§£æ Mapper æ–‡ä»¶ï¼ˆXMLMapperBuilderï¼‰
   - æ„å»º Configuration å¯¹è±¡
   - åˆ›å»º SqlSessionFactory</p><ol><li><strong>æ‰§è¡Œé˜¶æ®µ</strong>ï¼š</li>
</ol>   - é€šè¿‡ MapperProxy åŠ¨æ€ä»£ç†æ‰§è¡Œæ–¹æ³•
   - MapperMethod å°è£…æ–¹æ³•è°ƒç”¨
   - SqlSession ç®¡ç†ä¼šè¯
   - Executor æ‰§è¡Œ SQL
   - StatementHandler å¤„ç†è¯­å¥
   - ParameterHandler è®¾ç½®å‚æ•°
   - ResultSetHandler å¤„ç†ç»“æœé›†</p><ol><li><strong>æ‰©å±•æœºåˆ¶</strong>ï¼š</li>
</ol>   - æ’ä»¶æœºåˆ¶ï¼ˆInterceptor + Pluginï¼‰
   - ç¼“å­˜æœºåˆ¶ï¼ˆCache æ¥å£ + è£…é¥°å™¨ï¼‰
   - åŠ¨æ€ SQLï¼ˆSqlNode + DynamicContextï¼‰</p><h3>10.2 è®¾è®¡æ¨¡å¼æ€»ç»“</h3><p>| è®¾è®¡æ¨¡å¼ | åº”ç”¨åœºæ™¯ | å…¸å‹ç±» |
|---------|---------|--------|
| å·¥å‚æ¨¡å¼ | åˆ›å»º SqlSessionFactory | SqlSessionFactoryBuilder |
| å»ºé€ è€…æ¨¡å¼ | æ„å»ºå¤æ‚å¯¹è±¡ | XMLConfigBuilder, XMLMapperBuilder |
| ä»£ç†æ¨¡å¼ | Mapper æ¥å£ä»£ç† | MapperProxy |
| ç­–ç•¥æ¨¡å¼ | ä¸åŒçš„æ‰§è¡Œå™¨ | SimpleExecutor, ReuseExecutor, BatchExecutor |
| è£…é¥°å™¨æ¨¡å¼ | ç¼“å­˜åŠŸèƒ½å¢å¼º | LruCache, FifoCache |
| æ¨¡æ¿æ–¹æ³•æ¨¡å¼ | æ‰§è¡Œå™¨åŸºç±» | BaseExecutor |
| è´£ä»»é“¾æ¨¡å¼ | æ’ä»¶æ‹¦æˆª | InterceptorChain |</p><h3>10.3 å­¦ä¹ å»ºè®®</h3><ol><li>ä»ç®€å•ç¤ºä¾‹å…¥æ‰‹ï¼Œç†è§£åŸºæœ¬ç”¨æ³•</li>
<li>é‡ç‚¹ç†è§£åˆå§‹åŒ–æµç¨‹å’Œæ‰§è¡Œæµç¨‹</li>
<li>æ·±å…¥ç ”ç©¶åŠ¨æ€ SQL çš„å®ç°æœºåˆ¶</li>
<li>å­¦ä¹ æ’ä»¶æœºåˆ¶å’Œç¼“å­˜æœºåˆ¶</li>
<li>ç»“åˆæºç è°ƒè¯•ï¼ŒåŠ æ·±ç†è§£</li>
</ol>
é€šè¿‡æœ¬æ–‡çš„å­¦ä¹ ï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š
<ul><ol><li>ç†è§£ MyBatis çš„æ•´ä½“æ¶æ„å’Œæ ¸å¿ƒç»„ä»¶</li>
<li>æŒæ¡ MyBatis çš„åˆå§‹åŒ–å’Œæ‰§è¡Œæµç¨‹</li>
<li>äº†è§£åŠ¨æ€ SQLã€ç¼“å­˜ã€æ’ä»¶ç­‰æ ¸å¿ƒæœºåˆ¶çš„å®ç°åŸç†</li>
<li>å…·å¤‡é˜…è¯»å’Œæ·±å…¥ MyBatis æºç çš„èƒ½åŠ›</li>
</ol></ul>
        </div>
      </article>
    </div>
  </main>

  <footer class="footer">
    <div class="container">
      <p>&copy; 2026 zhizhi2213. All rights reserved.</p>
    </div>
  </footer>

  <script src="/assets/script.js"></script>
</body>
</html>
